<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sabby</title>
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
    <style>
      body, html, canvas {
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        outline: none;
      }
    </style>
  </head>
  <body style="margin: 0; width: 100vw; height: 100vh; background: black; pointer-events:none;overflow: hidden;user-select: none;">
        <canvas style="display: block;" id="renderMan" ></canvas>
	<script>
        const getQueryParam = (paramName) => new URL(window.location.href).searchParams.get(paramName);
        const SIGNAL_PAUSE = 0;
        const SIGNAL_READY = 1;
        const SIGNAL_RUN = 2;
        const PARTICLE_COUNT = ~~getQueryParam('count') || 2_000_000;
        // const PARTICLE_COUNT = 10_000_000;
        const WORKER_COUNT = navigator.hardwareConcurrency - 1;
        const chunkSize = Math.floor(PARTICLE_COUNT / WORKER_COUNT);
        const workerPool = [];
        let activeWorkers = 0;
        const stride = 4; // 4 floats x,y,dx,dy;
        const byte_stride = stride*4; // 4 bytes per float
        const sabParticles = new SharedArrayBuffer(PARTICLE_COUNT * byte_stride);
        const sabViewParticles = new Float32Array(sabParticles);
        // dt + mouse x + mouse y + touch down + screen with + screen height
        const sabSimData = new SharedArrayBuffer(4+4+4+4+4+4);
        const sabViewSimData = new Float32Array(sabSimData);
        const canvas = document.getElementById('renderMan');
        const context = canvas.getContext('2d');
        let sabPixelBuffs = new SharedArrayBuffer(WORKER_COUNT*window.innerWidth*window.innerHeight*3);
        let sabViewPixelBuffs = new Uint8Array(sabPixelBuffs);
        let backbuffer = new ImageData(window.innerWidth, window.innerHeight);
        
        // windowing init
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        sabViewSimData[4] = canvas.width;
        sabViewSimData[5] = canvas.height;
        window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          sabPixelBuffs = new SharedArrayBuffer(WORKER_COUNT*canvas.width*canvas.height*3);
          sabViewPixelBuffs = new Uint8Array(sabPixelBuffs);
          backbuffer = new ImageData(canvas.width, canvas.height);
          sabViewSimData[4] = canvas.width;
          sabViewSimData[5] = canvas.height;
        });
        window.addEventListener('mousemove', e => {
          sabViewSimData[1] = e.clientX;
          sabViewSimData[2] = e.clientY;
        });
        window.addEventListener('mousedown', e => {
          sabViewSimData[3] = 1;
        });
        window.addEventListener('mouseup', e => {
          sabViewSimData[3] = 0;
        });
        window.addEventListener('touchmove', e => {
          const touch = e.touches[0];
          sabViewSimData[1] = touch.clientX || touch.pageX;
          sabViewSimData[2] = touch.clientY || touch.pageY;
        });
        window.addEventListener('touchstart', e => {
          const touch = e.touches[0];
          sabViewSimData[1] = touch.clientX || touch.pageX;
          sabViewSimData[2] = touch.clientY || touch.pageY;
          sabViewSimData[3] = 1;
        });
        window.addEventListener('touchend', () => {
          sabViewSimData[3] = 0;
        });
        window.addEventListener('touchcancel', () => {
          sabViewSimData[3] = 0;
        });

        //setup workers
        activeWorkers = WORKER_COUNT;
        for(let i = 0;i< WORKER_COUNT;i++) {
          const worker = new Worker('./worker.js');
          worker.addEventListener('message', onWorkerMessage);
          workerPool.push(worker);
          worker.postMessage({
            sabParticles, id: i, chunkSize, chunkOffset: chunkSize*i, stride, sabSimData, sabPixelBuffs
          });
        }

        //init particles
        for(let i = 0;i < PARTICLE_COUNT;i++) {
          sabViewParticles[i*stride] = Math.random() * canvas.width;
          sabViewParticles[i*stride+1] = Math.random() * canvas.height;
          sabViewParticles[i*stride+2] = (Math.random()*2-1)*10;
          sabViewParticles[i*stride+3] = (Math.random()*2-1)*10;
        }

      console.log('workers loading...');
      function onWorkerMessage() {
        activeWorkers--;
        if (activeWorkers !== 0) {
          return;
        }
        render();
        requestAnimationFrame(runSimulation);
      };

      let lastTime = 1;
      function runSimulation(currentTime) {
        const dt = Math.min(1, (currentTime - lastTime) / 1000);
        lastTime = currentTime;
        sabViewSimData[0] = dt;
        activeWorkers = WORKER_COUNT;
        workerPool.forEach((worker, i) => {
          worker.postMessage({}); 
        });
      }

      function render() {
        const width = canvas.width;
        const height = canvas.height;
        const pixels = backbuffer.data;
        const pixStride = width*height*3;
        for (let i = 0; i < width*height;i++) {
          let r = 0, g = 0, b = 0;
          for (let j = 0;j < WORKER_COUNT;j++) {
            r += sabViewPixelBuffs[j*pixStride + i*3];
            g += sabViewPixelBuffs[j*pixStride + i*3 + 1];
            b += sabViewPixelBuffs[j*pixStride + i*3 + 2];
          }
          pixels[i*4] = r;
          pixels[i*4+1] = g;
          pixels[i*4+2] = b;
          pixels[i*4+3] = 255;
        }
        context.putImageData(backbuffer, 0, 0);
      }
    </script>
  </body>
</html>