<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sabby</title>
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
  </head>
  <body style="margin: 0; width: 100vw; height: 100vh; background: black; pointer-events:none;overflow: hidden;user-select: none;">
        <canvas style="display: block;" id="renderMan" ></canvas>
	<script>
    function getQueryParam(paramName, urlString = window.location.href) {
    // Create a URL object
    var url = new URL(urlString);

    // Get the search params from the URL
    var searchParams = url.searchParams;

    // Return the value of the specified parameter
    return searchParams.get(paramName);
}
        const SIGNAL_RUN = 0;
        const SIGNAL_PAUSE = 1;
        const SIGNAL_READY = 2;
        const PARTICLE_COUNT = ~~getQueryParam('count') || 2_000_000;
        // const PARTICLE_COUNT = 10_000_000;
        const CPU_CORES = navigator.hardwareConcurrency - 1;
        const chunkSize = Math.floor(PARTICLE_COUNT/CPU_CORES);
        const workerPool = [];
        const stride = 4; // 4 floats x,y,dx,dy;
        const byte_stride = stride*4; // 4 bytes per float
        const sabParticles = new SharedArrayBuffer(PARTICLE_COUNT * byte_stride);
        const sabViewParticles = new Float32Array(sabParticles);
        const sabSignals = new SharedArrayBuffer(CPU_CORES);
        const sabViewSignals = new Uint8Array(sabSignals);
        // dt + mouse x + mouse y + touch down + screen with + screen height
        const sabSimData = new SharedArrayBuffer(4+4+4+4+4+4);
        const sabViewSimData = new Float32Array(sabSimData);
        const canvas = document.getElementById('renderMan');
        const context = canvas.getContext('2d');
        let sabPixelBuffs = new SharedArrayBuffer(CPU_CORES*window.innerWidth*window.innerHeight*3);
        let sabViewPixelBuffs = new Uint8Array(sabPixelBuffs);
        let backbuffer = new ImageData(window.innerWidth, window.innerHeight);
        window.temp1 = sabViewPixelBuffs;
        // windowing init
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        sabViewSimData[4] = canvas.width;
        sabViewSimData[5] = canvas.height;
        window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          sabPixelBuffs = new SharedArrayBuffer(CPU_CORES*canvas.width*canvas.height*3);
          sabViewPixelBuffs = new Uint8Array(sabPixelBuffs);
          backbuffer = new ImageData(canvas.width, canvas.height);
          sabViewSimData[4] = canvas.width;
          sabViewSimData[5] = canvas.height;
        });
        window.addEventListener('mousemove', e => {
          sabViewSimData[1] = e.clientX;
          sabViewSimData[2] = e.clientY;
        });
        window.addEventListener('mousedown', e => {
          sabViewSimData[3] = 1;
        });
        window.addEventListener('mouseup', e => {
          sabViewSimData[3] = 0;
        });
        window.addEventListener('touchmove', e => {
          const touch = e.touches[0];
          sabViewSimData[1] = touch.clientX || touch.pageX;
          sabViewSimData[2] = touch.clientY || touch.pageY;
        });
        window.addEventListener('touchstart', e => {
          const touch = e.touches[0];
          sabViewSimData[1] = touch.clientX || touch.pageX;
          sabViewSimData[2] = touch.clientY || touch.pageY;
          sabViewSimData[3] = 1;
        });
        window.addEventListener('touchend', () => {
          sabViewSimData[3] = 0;
        });
        window.addEventListener('touchcancel', () => {
          sabViewSimData[3] = 0;
        });

        //setup workers
        for(let i = 0;i< CPU_CORES;i++) {
          const worker = new Worker('./worker.js');
          workerPool.push(worker);
          worker.postMessage({
            sabParticles, sabSignals, id: i, chunkSize, chunkOffset: chunkSize*i, stride, sabSimData, sabPixelBuffs
          });
        }

        //init particles
        for(let i = 0;i < PARTICLE_COUNT;i++) {
          sabViewParticles[i*stride] = Math.random() * canvas.width;
          sabViewParticles[i*stride+1] = Math.random() * canvas.height;
          sabViewParticles[i*stride+2] = (Math.random()*2-1)*10;
          sabViewParticles[i*stride+3] = (Math.random()*2-1)*10;
        }

        // wait for worker ready signal
        const handle = setInterval(() => {
          console.log('waiting for workers....', sabViewSignals);
          if (sabViewSignals[sabViewSignals.length-1] !== SIGNAL_READY) {
            return;
          }
          clearInterval(handle);
          requestAnimationFrame(runSimulation);
        }, 100);

      let lastTime = 1;
      function runSimulation(currentTime) {
        const dt = Math.min(1, (currentTime - lastTime) / 1000);
        lastTime = currentTime;
        sabViewSimData[0] = dt;
        for(let i = 0;i< CPU_CORES;i++) {
            sabViewSignals[i] = SIGNAL_RUN;
        }
        render();
        requestAnimationFrame(runSimulation);
      }

      function render() {
        const width = canvas.width;
        const height = canvas.height;
        const pixels = backbuffer.data;
        const pixStride = width*height*3;
        for (let i = 0; i < width*height;i++) {
          let r = 0, g = 0, b = 0;
          for (let j = 0;j < CPU_CORES;j++) {
            r += sabViewPixelBuffs[j*pixStride + i*3];
            g += sabViewPixelBuffs[j*pixStride + i*3 + 1];
            b += sabViewPixelBuffs[j*pixStride + i*3 + 2];
          }
          pixels[i*4] = r;
          pixels[i*4+1] = g;
          pixels[i*4+2] = b;
          pixels[i*4+3] = 255;
        }
        context.putImageData(backbuffer, 0, 0);
      }
    </script>
  </body>
</html>
